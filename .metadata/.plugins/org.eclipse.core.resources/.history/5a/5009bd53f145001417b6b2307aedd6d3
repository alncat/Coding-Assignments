import java.util.*;

class LinearSparseArray<T> extends ASparseArray {

  private int[] indices;
  private Vector<T> data;
  private int totalSlots, counter;



  public LinearSparseArray(int initialSlots) {
    indices = new int[2000000];
    data = new Vector<T>();
    totalSlots = initialSlots;
    counter = 0;
  }

  /**
   * Add element to the array at position.
   * 
   * @param position position in the array
   * @param element data to place in the array
   */
  @SuppressWarnings("unchecked")
  @Override
  public void put(int position, Object element) {

    indices[counter] = position;
    totalSlots++;
    data.add(counter, (T) element);
    counter++;
  };

  /**
   * Get element at the given position.
   *
   * @param position position in the array
   * @return element at that position or null if there is none
   */
  public T get(int position) {
    
   for (int i = 0; i < counter; i++) {
      if (indices[i] == position) {
        return data.get(i);
      }
    }
    return null;
  }

  /**
   * Create an iterator over the array.
   *
   * @return an iterator over the sparse array
   */
  public Iterator<IIndexedData<T>> iterator() {
    Iterator<IIndexedData<T>> myIter = new LinearIndexedIterator<T>(data, indices);
    return myIter;
  }


  @SuppressWarnings("hiding")
  class LinearIndexedIterator<T> implements Iterator<IIndexedData<T>> {

    private int index;
    private IndexedData<T> myData;
    private Vector<IndexedData<T>> vecData;


    public LinearIndexedIterator(Vector<T> inputData, int[] posIndex) {
      index = 0;
      vecData = new Vector<IndexedData<T>>();
      for (int i = 0; i < inputData.size(); i++) {
        myData = new IndexedData<T>(i * 100, inputData.get(i));
        vecData.add(myData);
      }


    }

    public boolean hasNext() {
      if (data.size() < index + 1) {
        return false;
      } else {
        return true;
      }
    }

    public IIndexedData<T> next() {
      IIndexedData<T> temp = vecData.get(index);
      index++;
      return temp;
    }

    public void remove() {
      throw new RuntimeException("There not be any removes called.");
    }


  }

  public class LinearSearch {

    public int find(final int[] data, final int key) {
      for (int i = 0; i < data.length; ++i) {
        if (data[i] > key) {
          return -1;
        } else if (data[i] == key) {
          return i;
        }
      }
      return -1;
    }
  }

}
